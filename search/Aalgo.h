#ifndef AALGO_H
#define AALGO_H

#include <Aopdefs.h>		// provided by user

#include <Alist.h>
#include <string.h>
#include <Aop.h>

#include <iostream.h>
#include <stdlib.h>


class Aenforcer_t;
class Aphyprop_t;
class Aphynode_t; 
class Bexec_info_t;		// forward reference		

/***************************************************************************

  ALGORITHMS

  algorithms are different ways to physically implement a given 
  operator. thus, for each logical node, we can have different 
  physical implementations (depending on different algorithms) 
  giving rise to the same output. This gives rise to to multiple 
  Aphynode_ts associated with the same logical node.

  each algorithm has a MakePhyNodes function which supposed to
  generate all the Aphynode_ts that can possibly arise from 
  implementing the operator of a given Alognode_t using that
  algorithm.

  this MakePhyNodes function makes use of an overloaded
  MakePhyNode function to do the job.


***************************************************************************/


class Aalgo_t {
private:
  char *name;	// name of the algorithm. supplied by DBI.
  AalgoNumber number; // a unique number supplied by DBI.

protected:
  Alist_t<Aenforcer_t> *enforcers; // array of list of enforcers.
                                   // one list for each input.

public:
  Aalgo_t (char *newname, AalgoNumber n, 
		Alist_t<Aenforcer_t> *e = 0) {
    name = newname; number = n; enforcers = e;
  }

  virtual ~Aalgo_t (void) {}

  virtual Aalgo_t *Duplicate (void) const = 0;
               // this virtual function should return a newly allocated object
               // which is an exact replica of this one.
               // read comment in file ./README to find out why it is required.
               // the DBI has to provide this function

  char *GetName (void) {return name;}
  AalgoNumber GetNumber (void) {return number;} 

  virtual int Arity (void) const = 0; 
  virtual void MakePhyNodes (Alognode_t *) = 0; 

  virtual Aphyprop_t *Constraint (Alognode_t *,
					       Aphynode_t *, 
					       int inputnumber = 0) {
    return 0;	// default == 0. unless DBI specifies otherwise
  }		// this function shoule return the physical properties
		// required of the given physical node if it needs to be
		// used as the Nth input of this algorithm. should
		// return 0 if the given node already satisfies
		// the constraints or if the node cannot be used as
                // an input to this algorithm at all.
                // DBI will usually redefine this function.

  virtual Alist_t<Aalgo_t> Clones (Alognode_t *, Aphynode_t **inputs = 0);
		// this is supposed to give a list of algorithm objects
		// which represent different ways of applying this algorithm
		// to these inputs, but with different parameters
		// DBI is supposed to redefine this function if s/he 
		// doesnt like the default behaviour
  virtual int CanBeApplied (Alognode_t *, Aphynode_t **inputs = 0) {return 1;}
	        // returns true if this algo can be applied to these inputs.


  virtual void Apply (Alognode_t *lognode, Aphynode_t **inputs) {
    cerr << "error: Aalgo_t::Apply called" << endl; exit (1);
  }		// this function should construct all the physical nodes
                // of the given logical node which can result from the 
                // application of this algorithm to the given physical nodes.
                // the DBI will usually NOT need to redefine this function

  virtual Alist_t<Aphynode_t> 
    EnforceNthConstraint (Alognode_t *, 
			       Aphynode_t *input, int N = 0);
                // apply the proper enforcer(s) to the Nth input and
                // return a list of resulting phynode(s)
                // (which will satisfy the input constraints).
                // under normal circumstances the DBI should NOT have to
                // redefine this function.
                // the DBI will usually NOT need to redefine this function

  virtual Aphyprop_t *MakePhyProps (Aphynode_t *)=0;
                // make the physical properties for the given physical node.
                // assume that the rest of the members of the physical node
                // have already been filled in...
                // the DBI will have to provide this function

  virtual void Execute (Bexec_info_t &exec_info) = 0;
		// to be used by the DBI for execution of an access
		// plan generated by APG. Bexec_info_t is a DBI supplied
		// class

  static void Prune (Aphynode_t *);
                // After a new physical node has just been created by an
                // Aalgo_t::MakePhyNodes some pruning of the search
                // tree is done (to eliminate redundant access plans).
};

class Aunaryalgo_t : public Aalgo_t {
private:
public:
  Aunaryalgo_t (char *name, AalgoNumber n, Alist_t<Aenforcer_t> *e = 0) 
    : Aalgo_t (name, n, e) {}
  virtual ~Aunaryalgo_t (void) {}
  int Arity (void) const {return 1;}

  virtual void MakePhyNodes (Alognode_t *);
		// DBI will usually NOT need to redefine this function

  virtual void Apply (Alognode_t *, Aphynode_t *input);
		// DBI will usually NOT need to redefine this function

  virtual Alist_t<Aunaryalgo_t> Clones (Alognode_t *, Aphynode_t *input);
		// this is supposed to give a list of algorithm objects
		// which represent different ways of applying this algorithm
		// to this input, but with different parameters
		// DBI is supposed to redefine this function if s/he 
		// doesnt like the default behaviour
  virtual int CanBeApplied (Alognode_t *, Aphynode_t *input) {return 1;}
	        // returns true if this algo can be applied to these inputs.
};

class Aenforcer_t : public Aunaryalgo_t {
private:
public:
  Aenforcer_t (char *name, AalgoNumber n, Alist_t<Aenforcer_t> *e = 0) 
    : Aunaryalgo_t (name, n, e) {}
  virtual ~Aenforcer_t (void) {}

  virtual Alist_t<Aphynode_t> Enforce (Aphynode_t *, 
				      Aphyprop_t *) = 0;
		// apply this enforcer to the given phynode so that it
		// finally has the given physical properties.
		// the DBI will have to provide this function

//  virtual void Apply (Alognode_t *, Aphynode_t *input);
//  an Enforcer does not need an Apply function
		// this is different from Aunaryalgo_t::Apply because
		// the resultant nodes should not be Pruned in case of
		// enforcers DBI will usually NOT need to redefine this 
		// function.
};

class Abinalgo_t : public Aalgo_t {
private:
public:
  Abinalgo_t (char *name, AalgoNumber n, 
		      Alist_t<Aenforcer_t> *e = 0) 
    : Aalgo_t (name, n, e) {}
  virtual ~Abinalgo_t (void) {}

  int Arity (void) const {return 2;}

  virtual void MakePhyNodes (Alognode_t *);
                // DBI will usually NOT need to redefine this function

  virtual void Apply (Alognode_t *,
		      Aphynode_t *leftinput,
		      Aphynode_t *rightinput);
                // DBI will usually NOT need to redefine this function

  virtual Alist_t<Abinalgo_t> Clones (Alognode_t *, 
					      Aphynode_t *leftinput,
					      Aphynode_t *rightinput);
		// this is supposed to give a list of algorithm objects
		// which represent different ways of applying this algorithm
		// to this input, but with different parameters
		// DBI is supposed to redefine this function if s/he 
		// doesnt like the default behaviour
  virtual int CanBeApplied (Alognode_t *, Aphynode_t *leftinput, 
			    Aphynode_t *rightinput) {return 1;}
	        // returns true if this algo can be applied to these inputs.
};

#endif /* AALGO_H */
