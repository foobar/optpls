#ifndef AHASH_H
#define AHASH_H

#include <Alist.h>
class Aphynode_t;

class Alogprop_t;
class Aphyprop_t;


/***************************************************************************

  BEWARE!!!

  do not make any changes to this file unless you are very
  very sure of what you are doing.

***************************************************************************/
/***************************************************************************

  PRUNING.

  whenever a new physical node is created 
  there is potential for ii_cost based pruning.

  remember that each physical node stands for an access plan
  (for whatever partial operator tree it is supposed to be
  implementing).

  so if there exists a physical node in our search tree which
  produces the the same output as the new node (i.e. all the 
  logical properties are same AND the physical properties are also 
  the same) then we keep only the the less expensive one around
  to be considered for further optimization. the more expensive
  one is pruned out. we call this an EXACT MATCH.
  in this case, if the new node is less expensive then it
  REPLACEs the older one in the search tree or if it is more 
  expensive then (since it is not useful to anyone) it commits SUICIDE
  by deleting itself.
  
  if no exact match is found we continue with pruning.

  if there is a physical node whose logical properties are the
  same as the new node and its physical properties are not
  but its physical properties are NOT INTERESTING
  and it is more expensive than the new node then that node
  can be pruned out (because the new node can provide everything
  that the old one provided (and more) at a lesser ii_cost).
  the desicion of whether the physical properties of a node are
  INTERESTING or not is left to the DBI (database implementor)
  through the use of the Aphynode_t::IsInteresting member funtion.

  in such a situation we call the new node a REPLACER (because
  it is going to remove/KILL the older node from the search tree) and
  the new node a REPLACEE.

  the situation is reversed if the physical properties if the new
  node are NOT INTERESTING. in that case if there is any already
  existing node which has the same logical properties (obviously
  it has INTERESTING physical properties) and is less expensive than
  the new node, then the new node need not be kept around for the 
  later phase of optimization. hence the new node commits SUICIDE. 

***************************************************************************/

class Ahashnode_t {
friend class Ahashtable_t;
friend class Ahashid_t;
private:
  Aphynode_t *node;
  Alogprop_t *logprops;
  Aphyprop_t *phyprops;
  Alist_t<Ahashnode_t> *listofreplacers; // nodes which can replace this node.

private: // this is a private class
  Ahashnode_t (Aphynode_t *);
  Ahashnode_t (Alogprop_t *);

  ~Ahashnode_t (void);

  void NewPhyNode (Aphynode_t *);
};


/***************************************************************************

  A note on hashing.
  
  since the hashing is required to locate nodes with equivalent
  logical properties and physical properties and since these
  classes are supplied by the DBI, the hash function has to
  be implemented by the DBI.

  to do this, we require the DBI to provide us with two functions
  1) the Alogprop_t.Hash () function.
     the DBI is expected to guarantee that whenever two 
     instances of the Alogprop_t class are deemed to be
     equivalent by the Alogprop_t.IsEqualTo function then
     their Alogprop_t.Hash () values must be equal.
     further, the DBI should attempt to write this function such that
     different logprops objects return different values.
  2) the Aphyprop_t.Hash (Alogprop_t *) function.
     here two (logprops,phyprops) should give
     the same hash values if they are equivalent according to the
     Alogprop_t.IsEqualTo and the Aphyprop_t.IsEqualTo
     functions.

  these hashed numbers are rehashed by our hashtable to produce an integer
  from 0 to (arraysize - 1). in case of nodes which are not INTERESTING, 
  the Alogprop_t.Hash value is used for rehashing (because the
  physical properties are not interesting). for other nodes the
  Aphyprop_t.Hash value is used for rehashing since the physical
  properties are also important in this case.

***************************************************************************/

class Ahashid_t {
private:
  Aphynode_t *node;
  Ahashnode_t *exactmatch;
  Alist_t<Ahashnode_t> *replacers;
  Ahashnode_t *replacee;

 
  int logicalhashnumber; // value generated by Alognode_t.Hash
  int physicalhashnumber; // value returned by the Aphynode_t.Hash

  void FindReplacee (void);
  
public:
  Ahashid_t (Aphynode_t *newnode);

  static void InitializeHashTable (void);
  static void EmptyHashTable (void);
  
  Aphynode_t *GetExactMatch (void);   // there'll be only one exact match
  Aphynode_t *GetNextReplacer (void); // there will be a list of replacers
  Aphynode_t *GetReplacee (void);	   // there can be only one replacee

  void Replace (void);
  void KillReplacee (void);
  void Insert (void);
  void Suicide (void);
};


class Ahashtable_t {
private:
  int arraysize; // number of buckets in the hashtable
  Alist_t<Ahashnode_t> *hasharray; // this is an array of lists
				   // each element is a list of Ahashnode_ts
  static int abs (int x) {return x < 0 ? -x : x;}
  int Rehash (int logicalorphysicalnumber) {
    return abs (logicalorphysicalnumber) % arraysize; 
  }

public:
  Ahashtable_t (int thearraysize = 67);
  ~Ahashtable_t () { if (hasharray) delete [] hasharray; }

  Ahashnode_t *FindMatch (Aphynode_t *, int hashnumber);
		// in this, for INTERESTING nodes the hashnumber
		// should be the value returned by the
		// Aphyprop_t.Hash function. for the
		// non-INTERESTING nodes the Alogprop_t.Hash
		// value should be used.


  void Insert (Ahashnode_t *, int hashnumber);
  Ahashnode_t *FindReplacee (Aphynode_t *, int hashnumber);

  void EmptyHashTable (void); // call between queries.
};
#endif /* AHASH_H */
